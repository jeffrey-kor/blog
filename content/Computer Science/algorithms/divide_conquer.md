---
title: "Divide_conquer"
date: 2021-04-21T13:28:51+09:00
draft: true
categories:
  - "Category 1"
  - "Category 2"
tags:
  - "Test"
  - "Another test"
thumbnail: "img/placeholder.jpg"
comments: true
authorbox: true
pager: true
toc: true
sidebar: "right"
widgets:
  - "search"
  - "recent"
  - "taglist"
---
분할 정복 방법 원리, 특징, 처리 단계를 이해 및 설명
이진 탐색의 원리, 동작, 성능, 특징을 이해하고 적용
퀵 정렬의 원리, 동작, 분할함수, 성능을 이해하고 적용

# 분할 정복 (Divide Conquer)

##### 분할 정복 방법의 처리 단계
- 분할: 주어진 문제를 여러 개의 작은 문제로 분할
- 정복: 작은 문제를 순환적으로 분할
- 결합: 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구한다. (결합 단계가 없는 문제도 존재)

##### 대표적인 알고리즘
이진 탐색, 합병 정렬, 퀵 정렬, 선택 문제
분할과정에서는 어떤 특징을 가지고 있을까?
- 이진탐색
    - n/2 씩 쪼깨면서 제외할 대상을 정함
    - 나머지 쪼갠 부분을 다시 쪼개고 제외하고 하는 식
- 합병 정렬
    - 둘로 쪼개고 하나를 제외하지 않고 다 계산함
- 퀵 정렬
    - 퀵정렬도 두개로 쪼갬, 대신 쪼개질 때 왼쪽과 오른쪽으로 쪼갬
    - 이때 왼쪽과 오른쪽의 크기는 일정하지않음(일정하지 않은 두개로 쪼개는거)
    - 계속 일정하지 않은거로 쪼개면서 반복함
- 선택 문제
    - 둘로 쪼개지는데 퀵 정렬과 마찬가지로 왼쪽과 오른쪽의 크기는 일정하지 않은 채로 쪼개짐
    - 여기서 이진탐색처럼 일정하지 않은 크기지만 하나를 제외하고 나머지를 다시 쪼갬
    - 이거 꼭 정리해야함

개념과 원리
정렬된 상태의 입력 데이터에 대한 효과적인 탐색 방법
- 오름차순으로 정렬되었다고 가정
- 탐색방법
    배열의 가운데 원소A[mid]와 탐색키 x를 비교
    `mid = (start + last) / 2`
    1) 탐색키 = 가운데원소 -> 탐색 성공(mid 반환후 종료)
    2) 탐색키 < 가운데원소 -> 이진 탐색(원래크기 1/2인 왼쪽부분배열)
    3) 탐색키 > 가운데원소 -> 이진 탐색(원래 크기 1/2인 오른쪽 부분배열)
    분할: 배열의 가운데 원소를 기준으로 왼쪽과 오른쪽 부분배열로 분할 탐색키와 가운데 원소가 같으면
            가운데 원소의 배열 인덱스를 반환/종료
    정복: 탐색키가 가운데 원소보다 작으면 왼쪽 부분배열을 대상으로 이진 탐색을 순환 호출, 크면 오른쪽,
            부분배열을 대상으로 이진탐색을 순환 호출
    결합: 필요없음 (부분배열에 대해서 탐색 결과를 직접반환하기 때문에 결합단계가 필요없다)

```python3
class BinarySearch:
    @staticmethod
    def binary_search(self, arr: [], left: int, right: int, target: int) -> int:
        if left > right:
            return -1
        mid = math.floor((left + right) / 2)
        if target is arr[mid]:
            return mid
        elif target < mid:
            self.binary_search(arr, left, mid - 1, target)
        else:
            self.binary_search(arr, mid + 1, right, target)
```

이진 탐색에서의 분할 및 비교 회수
1번째 = 가운데가 맞는지
2번째 = 왼쪽의 가운데가 맞는지, 오른쪽의 가운데가 맞는지
3번쨰 = ..
k번째 = k번 분할했더니 데이터가 1개임, 이걸 정복하는거임
비교횟수는 최대 분할 횟수인 k와 마지막 남은 데이터 1개를 더해 k+1이 최대 비교횟수임
T(n) = 입력 크기 n에 대한 탐색과정에서의 모든 비교 횟수의 합
     = 맨 바깥 수준에서의 비교 횟수 + 순환 호출에서의 비교 횟수
     = T(n) = T(n/2) + O(1)  -> if (n>1), T(1) = 1
     = T(n) = O(logN)
삽입, 삭제, 연산은 부가적인 데이터 이동을 수반
- 데이터의 정렬 상태를 유지하기 위해 평균 n/2개의 데이터 이동이 발생
    -> 삽입/삭제가 빈번한 응용에서는 부적합

##### 퀵 정렬
특정 원소를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분 배열에 대해 퀵 정렬을 순환적으로 적용하는 방식
- 오름차순으로 정렬한다고 가정
피벗[pivot]
- 주어진 배열을 두 부분배열로 분할할 때 기준이 되는 특정 원소
    - 보통 주어진 배열의 첫번쨰 원소를 지정 [이게 중요하지만, 이게 일반적인 방법이긴 함]
- 피벗이 제자리를 잡도록 하여 정렬하는 방식
    분할전 [[30], 45, 20, 15, 40, 25, 35, 10] pivot = 30
    분할후 [[25, 10, 20, 15], [30], [40, 35, 45]] 
    두 부분배열에 대해서 퀵 정렬을 순환적으로 적용
    정렬만 하면 되므르 리턴 값이 없어서 결합이 필요업음

```python3
class QuickSort:
    @staticmethod
    def quick_sort(self, arr: [], n) -> []:
        pivot = partition(arr[0, n-1], n)
        QuickSort(arr[0 : pivot-1], pivot)
        QuickSort(arr[pivot+1 : n-1], n-pivot-1)

    @staticmethod
    def partition(self, arr, n):
        left, right = 1, n - 1
        while left < n and arr[left] < arr[0]:
            left += 1
        while right > 0 and arr[right] >= arr[0]:
            right -= 1
        if left < right:
            temp = arr[left]
            arr[left] = arr[right]
            arr[right] = temp
        else:
            temp = arr[0]
            arr[0] = arr[right]
            arr[right] = temp
        return right
```  

분할 함수(partition)의 수행 과정 **다시 공부 필요**
[30, 45, 20, 15, 40, 25, 35, 10]
피벗 = 30
1) 이때 피벗은 30으로 설정하고 left는 피벗의 다음값 45, 그리고 right는 10으로 둔다
2) 여기서 left는 pivot이 현재 내가 찾고자 하는 타겟보다 큰 값이 어디있는지 찾고, right는 피벗보다 값이 작은게 어디있는지 찾는다.
3) 각각 찾으면 서로 위치를 바꾼다, 여기선 10과 45가 위치가 바뀌게 된다 [30, 10, 20, 15, 40, 25, 35, 45]
4) 분할을 끝내는 시점은 left, right가 서로 역전이 되는 현상, 마지막으론 피벗과 left를 바꿔준다.
5) 이렇게 되면 피벗을 기준으로 왼쪽과 오른쪽이 생김. 왼쪽부터 정렬 수행, 그 후 과정을 반복
   -> arr[0]를 다시 피벗으로 잡고..... 반복....
6) 특이사항: [45:26] [88, 55, 66, 50, 85 .. 무한대]
    여기서 피벗은 88이고 left는 55, 그리고 right는 85이다. left와 right가 역전되는 상황이 와야 정렬을 끝낼 수 있는데.
    left는 보통 피벗의 값보다 큰 값을 찾고, right는 피벗의 값보다 작은 값을 찾도록 설정되어있다.
    이 상황에서 left가 계속 찾다가 피벗보다 큰 값을 찾지 못할경우에는 right와 역전이 되므로 정렬 없이 함수가 끝날 수 있다.
    이런 상황을 막기 위해 보통 right 뒤의 수는 무한대라고 가정을 하고, 피벗을 배열의 마지막 요소랑 바꿔준다는 특징이 있다.
    그럼 이렇게 된다 == [85, 55, 66, 50, 88]
    **손으로 꼭 풀어보자**
분할 함수 성능 분석
   분할 함수 partition()의 수행시간
   - 피벗과의 비교 횟수로 정해진다
   - 피벗 -> 레프트 <- 라이트를 비교하면서 계속 이동함 역전될때까지
    이때, 자리가 바뀌는 원소는 비교회수가 2번이 됌. 일단 비교해서 찾으면 연산뒤 다시 비교해야하므로
 퀵 정렬의 수행시간
     `pivot = partition()` => O(n)
     총 수행시간:
       퀵정렬의 수행시간: 왼쪽을 정렬하는데 걸리는 시간 + 오른쪽을 걸리는 시간 + 총 분할함수가 걸리는 시간
       T(1) = O(1)
       퀵 정렬은 분할된 부분배열의 크기가 어떠냐에 따라 성능시간이 달라짐.
       [1: 100]
       [2: 99] 또는 [100: 1] ㄷㄷ
       최악의 경우는 피벗은 그대로인데 왼쪽이나 오른쪽으로 몽땅 데이터가 분할되는 경우 ㄷㄷ
       -> 극심한 불균형적인 분할이 이루어지는 경우 [pivot][데이터] 또는 [데이터][pivot]
       -> 이런 경우는 정렬된 상태의 인풋이 들어올 경우가 될 수 있음
       -> 피벗이 항상 부분배열의 최솟값 또는 최댓값이 되는 경우도 이런 경우임
       -> T(n) = T(n-1) + O(n)
       -> T(n) = O(n^2)임 <최악의 경우
       -> 최선은 딱딱 데이터가 2개로 잘 나눠지는 경우, 이쁘게 나눠지는 경우
           -> 가장 균형적인 분할이 이루어지는 경우임
           -> 피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우
           -> 피벗이 항상 부분배열의 중간값이 되는 경우임
           -> 점화식: T(n) = T(n/2) + T(n/2) + O(n)
                    = T(n) = 2T(n/2) + O(n)
                    = T(n) = O(nlogN)
     
최선/평균 수행 시간 -> O(nlogN)
최악의 수행시간 -> O(n^2) X
    피벗 선택의 임의성만 보장되면 평균 성능을 보일 가능성이 매우 높음
    배열에서 임의의 값을 선택한 후, 배열의 처음 원소와 서로 교환한 후 정렬을 수행하면
    최악의 싱황을 면할 수 있음.

## 분할 정복 II (합병 정렬, 선택 문제)
합병 정렬 개념, 동작, 합병 함수, 성능, 특징을 이해하고 적용
선택 문제의 개념과 두 종류의 알고리즘
(분할 함수 이용, 중간값들의 중간값 이용)의 원리
동작, 성능을 이해하고 설명 할 수 있음

분할 정복: 순환적으로 문제를 푸는 하향식 접근 방법
주어진 문제의 입력을 더 이상 나눌 수 없을 때가지 두 개 이상의 작은 문제로 순환적으로 분할하고, 이렇게 분할된 작은 문제들을
각각 해결한 후 이 해들을 결합해서 원래 문제의 해를 구하는 방식
- `분할` - `정복` - `결합`
특징:
- 분할된 문제: 원래 문제와 동일(입력 크기만 감소), 서로 독립적
적용 알고리즘
이진 탐색, 퀵 정렬, 합병 정렬, 선택 문제
  
##### 합병 정렬
전형적인 분할 정복 방법이 적용된 알고리즘
- 분할: 주어진 배열을 **동일한 크기**의 두 개의 부분배열로 분할하고
- 정복: 분할된 각각의 부분배열을 순환적으로 정렬한 후
- 결합: 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만듦
데이터: [30, 50, 7, 40, 88, 15, 44, 55]
  [30, 50, 7, 40] [88, 15, 44, 55]
  [30, 50][7, 40] [88, 15][44, 55]
  
  [30][50][7][40] [88][15][44][55]
  
  [30, 50][7, 40] [15, 88][44, 55]
  [7, 30, 40, 50] [15, 44, 55, 88]

  [7, 15, 30, 40, 44, 50, 55, 88] < merge()를 호출함
  
문제는 분할은 되는데 어떻게 합칠까가 중요함
합병함수 merge 수행시간에서 멍때림 다시봐야함[17:26]

##### 합병 정렬 수행 시간
T(n) = T(n/2) + T(n/2) + merge(빅세타n)
T(n) = 2T(n/2) + O(n)
T(n) = O(nlogN)

##### 반복문 형태로 만드는법
합병만 하면됌
[30, 20, 40, 35, 5, 50, 45, 10, 25, 15]
[20, 30][35, 40] ...
[20, 30, 35, 40] ... 이런식임

##### 선택 문제
n개의 원소가 임의의 순서로 저장된 배열 A[0..n-1]에서 i번째로 작은 원소를 찾는 문제
i = 1 -> 최소값 찾는 문제
i = n / 2 -> 중간값 찾는 문제
i = n -> 최대값 찾는 문제

직관적인 방법
오름차순으로 정렬한 후 i번째 원소를 찾는 방법 -> O(nlogN), 최악의 경우에는 이 방식이 알고리즘1보다 나음
최소값을 찾는 과정을 i번 반복(i-1번째까지는 최소값을 찾은 후 삭제) -> O(in) **이해 안됌**[23:50]

- 알고리즘1 -> 최악 O(n^2), 평균 O(n) 알고리즘 <- 평균적으로 안좋은 알고리즘
- 알고리즘2 -> 최악 O(n), 평균 O(n) 알고리즘

최소값 찾기 알고리즘부터 시작해보자
: 각 데이터를 하나씩 모두 비교하는 방법 -> n개의 데이터에 대해 적어도 n-1번의 비교가 필요 -> o(n)
: 방법1: 최소값 찾은 후 최댓값 찾기(or: 최대값 찾은 후 최솟값 찾기)
: n개의 데이터에 대해서 n-1번 최소값을 찾은 후, n-1번 비교 + n-1개의 데이터에서 최대값을 찾는데 n-2번 비교
: 2n-3번의 비교 -> O(n)
: 개선해보자 이걸
-> 알고리즘2
    3/2 * n-2번의 비교하는 알고리즘이 있음 => 1/2 * n-2번 비교
    방법2는: 모든 원소를  두개씩 짝을 이루어서 동시에 최소값이랑 최대값과 비교하는 알고리즘
    ```python3
    FindMinMax(A[], n, min, max:
        if A[0] < A[1]:
            min = A[0]
            max = A[1]
        for (i = 2; i < n; i+=2) {
            if A[i] < A[i+1] {
                small = A[i];
                large = A[i+1]
            } else {
                small = A[i+1];
                large = A[i]
            }
            if small < min:
                min = small
            if large > max
                max = large
        )
    ```
최솟값고 최댓값을 모두 찾을 수 있음, 두개씩 비교해서 비교연산을 줄일 수 있긴함

알고리즘1: i번째로 작은 원소 찾기
퀵 정렬의 분할 함수인 partition()을 순환적으로 사용하는 방법
원리
    1) 피벗을 정한다음 피벗의 자리를 정해줌(예를 들어, 가운데로)
    2) 내가 찾고자 하는 인덱스가 i번째의 작은 원소가 피벗의 인덱스와 같으면 내가 찾고자 하는 i번째 원소가 맞음 => 리턴!
    3) i < p 왼쪽 부분 배열에 대해 순환적용
    4) i > p 오른쪽 부분배열에 대해 순환 적용

분할: 피벗을 기준으로 주어진 배열을 두 부분배열로 나누고, i가 피벗의 인덱스 p와 같으면 피벗의 값을 반환하고 종료
정복: 만약 그렇지 않다면, 인덱스 i가 포함된 부분배열에 대해 i < p 왼쪽 부분배열을 탐색하고, i > p 오른쪽 부분배열을 탐색한다.
결합: 필요업음
이거 선택정렬인가? 좀 어려운데

```python3 
def selection(self, arr, n, i):
    left, right = 0, n-1
    p = Partition(arr, n)
    if i is p+1:
        arr[p]
    elif i < p+1
        selection(arr[left: p-1], (p-1)-left+1, i)
    else:
        selection(arr[p+1: right ], right-(p+1)+1, i-p-1]
```
성능분석
최악의 경우 = 퀵 정렬의 최악의 경우
    분할 함수 partition()이 항상 하나의 부분배열만 생성하는 경우
    
    오름차순을 정렬된 상태에서 최댓값(i=n)을 찾는 경우
        분할 함수를 호출할 때 피벗 인덱스는 1씩 증가
        -> partition()을 o(n)번 호출 -> O(n^2)
    해결 방법: 항상 일정한 비율의 두 부분 배열로 분할 -> 최악의 경우에도 O(n)
평균적인 경우 -> O(n)

i번째로 작은 원소 찾기 -> 최악 O(n), 평균 O(n) -> 와 이건 신기한데, 공부 다시해보자 -> 중간값들의 중간값
개념과 원리:
    항상 일정한 비율의 두 부분배열로 분할되도록 특정 성질을 만족하는 값을 피벗으로 선택
    피벗을 어떻게 선택할까?
        1) 크기 n인 배열의 원소를 5개씩 묶어서 [n/5]개의 그룹을 만듬
            5의 배수가 되지 않아 그룹을 형성하지 못한 깎두기들은 그룹을 형성하지 못한 채 원소는 그대로 남겨둠
        2) 각 그룹에 대해서 중간값들을 찾음
        3) [n/5]개의 중간값을 대상으로 다시 중간값을 찾음
            -> 중간값들의 중간값 -> 피벗 졸라 신기하네 이거 ㅋㅋ
    와 이걸 어떻게 코드로짬, 진짜 졸라신기하네ㅋㅋ

[수도코드]
```javascript
function selecton_n(A[], n, i) {
    [단계1] if (n <= 5) {
        배열 A에서 i번째 원소를 찾아서 반환  
    } else {
        [단계2] ~ [단계6] 진행
    }
    [단계2] A의 원소를 5개씩 묶어서 [n/5]개의 그룹을 만든다
    [단계3] 각 그룹의 중간값을 구하고, 이들을 모아 배열 M을 구성한다
    [단계4] 중간값들의 중간값을 계산하기 위해서 서낵 함수를 순환한다.
    [단계5] p를 피벗으로 사용하여 A를 분할(피벗의 인덱스를 j라고 가정)
    [단계6] if(i==j+1) return A[i]
            else if (i < j+1) {
                selection_n(A[0..j-1], j, i)를 순환호출
            else {
                selection_n(A[j+1..n-1], n-j-1, i-j-1)를 순환호출
            }       
        }
    }

```

후. 졸라 힘들고 신기하고 대단하기도 하다.
DP 들어가기전에 공부좀 제대로 해야겠다. 와 분할정복을 좀 파보자.
연습문제도 좀 풀어보고, 이거 문제도 좀 풀면서 뭔가 감이 오긴 하는데. 힘들긴하다
논문 쓰는 법도 공부하고 영어공부도 따로해야겠네
파이토치 vs 텐서플로우

딥러닝을 이용한 컴퓨터 비전 커리큘럼
> GPT 메모, 자연어처리 메모, 컴퓨터 비전 메모. ㅋㅋ
