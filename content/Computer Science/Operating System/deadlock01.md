---
title: "교착 상태, Dead Lock의 조건"
date: 2021-05-06T16:42:41+09:00
draft: true
categories:
  - "Operating System"
tags:
  - "Operating System"
comments: true
authorbox: true
pager: true
toc: true
sidebar: "right"
widgets:
  - "search"
  - "recent"
  - "taglist"
---
## Dead Lock, 교착상태
Dead Lock, 교착 상태란 2개 이상의 프로세스가 서로 상대방의 작업이 끝나기만을 기다리고 있는 상태, 결과적으로 아무도 완료되지 못한 상태를 말한다.
대표적인 예로 식사하는 철학자 문제가 있다.

>

교착 상태와 기아 상태의 차이
그림으로 설명하자 도로 상황과 같다. 설명 끝내주게 잘하신다.

교착 상태의 특성
네 가지 조건이 동시에 만족될 경우 교착 상태가 발생할 수 있다.
- 상호배제 조건
- 점유대기 조건
- 비선점 조건
- 환형 대기 조건

#### 상호 배제 조건
프로세스들이 자원에 대한 배타적인 통제권을 요구
적어도 하나 이상의 자원은 공동으로 사용될 수 없다.
즉 필요로 하는 자원을 다른 프로세스가 점유하고 있으면 반드시 대기해야 한다는 것이다.

#### 점유 대기 조건
프로세스가 이미 다른 자원을 할당받아 배타적으로 점유하고 있는 상황에서 다른 프로세스가 점유하고 있는
자원이 해제되기를 기다리는 상황

#### 비선점 조건
프로세스에 할당된 자원은 그 프로세스가 사용을 마치고 스스로 반환하기 전에 제거되지 않는다. 
즉, 다른 프로세스에 의해서는 헤제되지 않는다.
누가 쓰고 있는 자원을 남이 뻇어갈수 없다

##### 환형 대기 조건
프로세스의 자원 점유 및 점유된 자원의 요구 관계가 환형을 이루며 대기한다.
도로와 같은 상황을 의미한다.

##### 자원할당 그래프
그래프 자료구조 공부 필요성
네가지 상황에 대해 표현하기 위해 자원 할당 그래프를 이용해서 표현한다.
자원 할당 그래프 G = (V, E)
- 정점의 집합 V = P U R
     - P = { p1, p2, ....Pn }: n개의 프로세스
     - R = { r1, r2, ....Rn }: m개의 자원 
- 방향 있는 간섭의 집합 E = Q U S
    Q = {(Pi, Rj): Pi <= P, Rj <= R}: 프로세스 Pi가 자원 Rj를 요구함(요구 간선) 
    S = {(Rj, Pi): Rj <= R, Pi <= P}: 자원 Rj가 프로세스 Pi에 할당됨(할당 간선)
- 자원할당 그래프의 예
[그림]() 27:00
- 교착 상태와의 관계
    - 상호배제 조건 - 할당간선
    - 점유대기 조건 - 할당간선
    - 비선점 조건 - 요구간선
    - 환형 대기 조건 - 사이클(Cycle)

    - 자원할당 그래프에 사이클이 없다면? -> 교착 상태 발생 X
    - 자원할당 그래프에 사이클이 존재한다면? -> 교착 상태 발생 O?X
        - 사이클이 존재하지만 교착 상태가 아닌 예는?
        - 하지만 이 사이클은 교착상태가 될 수 없다. 

- 교착 상태 처리
    - 교착상태 방지
      : 교착 상태의 필요조건 중 하나라도 발생할 수 없도록 막는다(네가지 필요조건)
    - 교착상태 회피
      : 프로세스에 필요한 자원의 최대량에 대한 정보를 활용하여 교착상태가 발생하지 않도록 한다.
      : 교착 상태가 발생하지 않도록 자원의 최대량을 활용하여 잘 회피해보자.
    - 교착상태 탐지 및 복구
      : 이미 교착상태가 발생한 상황에서 잘 탐지를 해서 이에 따른 적절한 조취를 취하여 정상상태로 복구하자.
      
#### 교착상태 방지
1. 상호배제 조건의 제거
- 공유할 수 있는 자원: 상호배제와 무관
- 공유할 수 없는 자원: 반드시 상호배제 해야한다.
=> 상호배제 조건을 제거해서 교착 상태를 방지하는 것은 불가능하다.
2. 점유대기 조건의 제거 (어떤 자원을 점유하고 있는 상태에서 다른 자원을 요구할때)
- 프로세스가 자원을 요청할때, 그 프로세스는 어떠한 자원도 할당받지 않는 상태
A. 방법 I (처음에 다 받아버리는거)
- 프로세스가 수행을 시작하기 전에 필요한 모든 자원을 한꺼번에 요구하여 할당 받음
- 자원의 이용률이 매우 낮아질 수 있다.
B. 방법 II (쓰다가 다른거 필요할 때 가지고 있던거 다 버리고 요구해서 쓰는법)
- 자원을 부분적으로 요청하여 할당받을 수 있도록 하되, 자원을 추가로 요청할 때에는 이전에 가지고 있던 자원을 반드시 모두 해제한 후 할당 받는다.
=> 기아상태가 발생할 수 있다? -> 예외적으로 다른 프로세스도 내가 요구한 자원을 요구하고 있는 경우 기아가 발생할 수 있음.
3. 비선점 조건의 제거
A. 방법 I
   => 자원을 점유하고 있는 프로세스가 즉시 사용할 수 없는 상황의 다른 자원을 요청하는 경우 점유하고 있던 자원을 해제
B. 방법 II
   => 프로세스가 가용하지 않은 자원을 요청
   => 그 자원이 하랑된 프로세스가 다른 자원을 기다리며 대기 중인지 조사
   => 대기 중이면 대기 상태인 프로세스로부터 자원을 선점하여 프로세스에게 할당, 대기 중이 아니라면 요청한 프로세스는 대기
   => 즉, 내가 요구하는 자원을 P2가 가지고 있으면서 안쓴다면 내가 뺏어서 쓰겠다.
      이럴때에는 상태를 쉽게 보관하고 복구할 수 있는 자원이 아니라면 적용이 불가능하다.
4. 환형 대기 조건의 제거
-> 새로운 함수를 정의하자. F:R -> N , R은 자원 유형의 집합, N은 자연수다.
   만약 r1이 프린터고, r2가 디스크 드라이브라면 r1의 f값을 1로 정의하겠다, r2의 f값을 5로 정의하겠다 라는 의미
   방법 I
   => 프로세스는 자원을 일련번호 기준으로 항상 오름차순으로 요청
   즉, 자원 ri를 점유하고 있는 경우 반드시 f(ri) < f(rj)인 경우만 rj를 요청할 수 있음
   방법 II
   => 프로세스가 자원 rj를 요구할 때마다 R(rj) <=f(ri)인 자원 rj는 모두 해제
   -> 함수 f의 정의는 전체 시스템의 성능에 큰 영향을 미치므로 실제로 사용되는 순서를 감안하여 정의해야 한다.

## Dead Lock II

#### 교착상태 회피
프로세스의 자원 사용에 대한 사전 정보를 활용하여 교착 상태가 발생하지 않는 상태에 머물도록 하는 방법
-> 사전 정보: 현재 할당한 자원, 가용상태의 자원, 프로세스들의 최대 요구량

프로세스 상태 영역
- 안전 상태
  : 교착 상태를 회피하면서 각 프로세스에게 그들의 최대 요구량까지 빠짐 없이 자원을 할당할 수 있는 상태
  : 안전 순서열이 존재한다.
- 불안전 상태
  : 교착 상태는 이 불안전상태에 잇을것이다. 불안전상태가 되면 무조건 교착상태가 되는것은 아니지만 가능성이 높다.
  : 안전 순서열이 존재하지 않는다.
안전 순서열이란?
  순서 있는 프로세스의 집합 <p1, p2, ... Pn>
  각 Pi에 대해 pi가 추가로 요구할 수 있는 자원 소요량이 현재 가용 상태이거나 혹은 현재 가용인 자원에 Pj(단, j < i)에 할당한 자원까지 포함하여
  할당 가능한 경우
  (단, j < i)에 할당된 자원까지 포함하여 할당 가능한 경우
  - 예를 통해 공부 [8:57]
  - 개념을 익히고 두번정도 다시 돌려보긴 해야함.
  - 교착 상태는 불안전 상태에서 발생
    불안전 상태: 할당 과정에 따라 교착 상태가 될 수

교착 상태 회피 알고리즘
- 각 자원 유형의 단위 자원이 여러 개일 경우
    은행원 알고리즘
- 각 자원 유형의 단위 자원이 하나밖에 없는 경우
    변형된 자원할당 그래프
  
##### 은행원 알고리즘 -> 위키 검색해서 공부 다시해보자. 어렵다..
자원을 요청받으면 그 자원을 할당해 주고 난 후의 상태를 계산해서 그것이 안전상태가 보장되는 경우에만
자원을 할당
AVAIL: 가용자원
MAX: pi의 최대요구
ALLOC: pi의 할당자원
NEED: Pi의 추가요구
fn 안전 알고리즘()
    work(x,y) -> isSatisfy?

    

 