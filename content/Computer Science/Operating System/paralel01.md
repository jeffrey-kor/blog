---
title: "Parallel Process"
date: 2021-05-04T15:53:18+09:00
draft: true
categories:
  - "Operating System"
tags:
  - "Operating System"
comments: true
authorbox: true
pager: true
toc: true
sidebar: "right"
widgets:
  - "search"
  - "recent"
  - "taglist"
---
## Parallel Process, 병렬 프로세스
Concurrency란, 여러 개의 프로세스 또는 쓰레드가 동시에 실행되는 시스템의 특성을 말한다.
병행 프로세서란, 동시에 실행되는 여러 개의 프로세스 또는 쓰레드를 말한다. 이런 병렬 프로세스의 특징과 문제점에 대해서 알아보자.

##### 병행 프로세스의 실행 형태
CPU의 개수에 따른 병행 프로세스의 실행 형태는 하나의 CPU에서 인터리빙 형식으로 실행된다.
프로세스는 동시에 하나의 작업만 처리할 수 있기 때문에 매 특정한 시간에 프로세스에게 CPU를 할당해 일을 처리하도록 한다.
이럴 때, CPU를 잘게 쪼개서 프로세스에게 할당하는 것이다. Round Robin Scheduling과 비슷한 방식이다.
인터리빙 방식이란?

CPU의 개수에 따른 병행 프로세스의 실행 형태
여러 개의 CPU에서 병렬 처리 방식으로 실행

메모리 구조에 따른 병행 프로세스의 실행 형태
강결합 멀티 프로세서 시스템: 공유 메모리 구조
하나의 컴퓨터 안에 여러개의 CPU를 가지고 있음

약결합 멀티 프로세서 시스템: 분산 메모리 구조
하나의 CPU를 가진 여러개의 컴퓨터가 네트워크로 연결되어 있는 분산 네트워킹 분산 구조

병행 프로세스들이 상호작용하는 경우 발생하는 문제
- 공유자원을 어떻게 점유 할것인가: 특정 자원을 여러 프로세스들이 같이 사용하려고 하는것
- 동기화를 어떻게 할 것이냐: 프로세스 사이의 어떤 순서관계를 정하는 것
- 통신을 어떻게 할것이냐

상황에 따른 문제 구분
- 단일 프로세스 내의 병행성
예)
  
```javascript
const a = (x, y) => { return x + y; }
const b = (z) => { return z + 1 }
const c = a(x, y) + c(z);
console.log(c);
```

이런 코드가 있다고 생각하자. a와 b 함수는 각기 다른 함수이며 의존성을 갖지 않는다.
하지만 c함수에서는 a와 b 모두 의존성을 가지고 있으며, a와 b 함수를 호출해 값을 반환한다음 메모리에
담아야한다. 하지만 이 때 c가 먼저 실행되면 안된다. 자바스크립트는 이런 실행순서를 보장하기 위한 문법을 작성해야하기 때문에
신경을 좀 써야한다.

이 하나의 프로그램 상에서 우선순위의 문제를 해결하기 위해:
1. 우선순위 그래프
2. Fork/Join 구조
3. 병행문
을 사용한다고 한다.

각각 무엇인지 알아보자

#### 우선순위 그래프

정점: 문장
방향 있는 간선: 우선순위 관계
DAG의 형태, 다이렉티드 어씨클릭 그래프(사이클이 없는 그래프)

```javascript
const a = (x, y) => { return x + y; }
const b = (z) => { return z + 1 }
const c = a(x, y) + c(z);
console.log(c);
```

#### Fork/Join 구조
Fork L: 2개의 병행 수행을 만들어준다, 이때 L은 레이블의 위치를 설명해준다.
Join N: 병행하는 n개의 흐름을 하나로 재결합 해준다.
분할 정복 알고리즘과 유사하게 생겼다.
Fork를 통해 a와 b의 실행 흐름을 나누고 join을 통해 두개의 실행흐름의 결과값을 merge 하는 형태

```javascript
const a = (x, y) => { return x + y; }
const b = (z) => { return z + 1 }
const fork = (a: Function, b: Function) => { return a(x, y) + b(z); }
const c = fork();
console.log(c);
```

#### 병행문
1개의 프로세스가 여러 가닥의 병렬 프로세스로 분할되었다가 다시 하나로 결합
parbegin / parend 구문
루틴을 실행하다가 병행성이 필요하다 생각하면 병행 구문을 시작해 루틴의 흐름을 나누고
병행 실행을 처리하게 되면 다시 루틴으로 돌아가 나머지 루틴을 실행하는 방식

```javascript
parbegin
    const a = (x, y) => { return x + y; } // 병행 실행
    const b = (z) => { return z + 1 } // 병행 실행
parend
    const c = () => { return a + b }
    console.log(c);
```

#### 비동기 병행 프로세스
동기화는 되지 않는다. 어떤 특정 시점에서는 선후관계가 필요하긴 함. 유기적 프로세스
비동기적 프로세스에서도 공유자원을 사용하고 있다면 어떻게 선후 관계를 정할 수 있을까?
여기서 공유자원에서는 어떤 시점에서는 하나의 프로세스의 접근 권한을 가지므로.
여기서 node.js의 이벤트루프를 이해할 수 있을 것 같다.
일단 운영체제 측면에서 데이터가 꼬이는 상황을 보자.
데이터베이스에 나의 계좌 컬럼이 있다고 가정해보자.
프로세스 A와 프로세스 B가 동시에 이 공유자원에 접근해 각각 원하는 금액을 입금해주고 싶다.
현재 나의 계좌에는 5만원이 들어가 있다. 자 비동기적으로 병렬 프로세스를 이해해보자.
이 공유자원에 A가 먼저 접근해 잔고를 확인한다. 잔고는 현재 5만원인 것을 확인하고, 여기에 3만원을 더해
8만원으로 만든 후 데이터베이스에 다시 입금을 하려고 한다. 이 때 프로세스 B가 비동기적으로 들어와서 데이터베이스의 잔고에
5만원인 것을 확인하고 2만원을 더한다. 이때 프로세스 A가 가진 금액은 8만원이고, 프로세스 B가 가진 금액은 7만원이다.
프로세스 A가 비동기적으로 8만원을 데이터베이스에 업데이트 해도 마지막에 처리된 프로세스 B가 7만원으로 데이터베이스의 금액을 7만원으로
업데이트를 한다면 10만원이 되어야 하는 금액이 7만원으로 될 수 밖에 없다. 이러한 문제는 상당히 치명적이다. 고객의 신뢰를 잃어버릴 수 있는 중대한 사안이다.
이때 소개되는 내용이 동기화와 임계영역인데 배워보자.

#### 동기화와 임계 영역
동기화란, 2개 이상의 프로세스에 대한 처리 순서를 결정하는 것을 말한다.
예) 동시에 사용할 수 없는 공유자원, 한 프로세스의 처리 결과에 따라 다른 프로세스의 처리가 영향을 받는 경우
-> 오라클과 mysql의 공유자원 접근에 대해 어떻게 처리하는지 고민해보고 공부해보자

임계영역이란,
2개 이상의 프로세스가 동시에 엑세스하면 안되는 공유자원을 엑세스 하는 코드 영역을 말한다.
2개 이상의 프로세스가 동시에 엑세스하면 안되는 공유자원을 임계 자원이라고 한다.
상호배제를 통해 2개 이상의 프로세스가 동시에 임계 영역에 진입하지 못하도록 하는 것을 말한다.
임계자원의 기준은 어떻게 설정??
입금 프로세스를 한 묶음으로 임계 영역이라고 이야기를 하면 프로세스 B에서 공유자원에 대한 접근을 막는다.

```
repeat
    진입영역
    임계영역
    헤제영역
    잔류영역
until false;
```

임계 영역 문제 해결을 위한 요구조건
상호 배제
: 하나의 프로세스가 임계영역에서 실행 중일 때, 다른 어떤 프로세스도 임계영역에서 실행될 수 없다.
진행
: 상호배제를 지키다보면 프로세스 B는 계속 기다려야한다. 이 때 하염없이 기다릴순 없으므로 어느 시점에서는 실행이 되어야 한다.
임계영역에서 실행 중인 프로세스가 없고 여러 프로세스가 임계 영역에 진입하고자 할 때 그 중에서 적절히 한 프로세스를
결정해야 하며 이 결정은 무한정 미룰수 없다.
제한된 대기
: 한 프로세스가 임계 여역 진입 요청을 한 후 수락될 때까지
다른 프로세스가 임계영역 진입을 허가 받는 횟수는 제한이 있어야 함.

##### 임계 영역 문제를 해결하기 위한 도구 (CPU에 따라서, 소프트웨어적으로 따라서)
- Test-and-Set
- 세마포어

##### Test-and-Set, Ts
상호 배제의 **하드웨어**적 해결 방법이다. 분리가 불가능한 단일 기계 명령어(원자적으로 수행)
```javascript
function test_and_set(target: boolean): boolean {
    begin
        test_and_set = target;
        target = true;
    end
}
```
이 함수가 실행되면 무조건 안에 있는 코드는 실행되어야 한다. 원자적 함수를 의미한다.
상호 배제를 구현해보자.
```javascript
repeat
    진입영역: while test_and_set(lock) do skip
    임계영역: 실행중인 프로세스
    헤제영역: lock = false
    잔류영역
until false;
```
진입영역에서 임계영역에서 누군가 공유자원을 쓰고 있으면 기다리고 있겠다, 또는 아니면 내가 쓰겠다를 설정하는 곳은 진입영역이고
안에 진입영역의 코드를 while문을 통해서 파라미터가 참이면 반복문을 계속 돌고, 거짓이면 임계영역으로 들어가게 된다.
헤제 영역에서는 나는 끝났으니까 다른 진입영역에 있는 애를 임계영역으로 넣어줭

그런데 여기에 문제점이 있다.
- 많은 프로세스가 임계 영역에 들어가기를 원할 때 기아가 발생할 수 있다.
starvation: 프로세스가 필요한 자원 할당을 받지 못하고 계속적으로 대기하게 되는 상황

- Busy waiting을 함으로써 다른 작업이 사용할 수 있는 CPU 사이클을 낭비하는 결과를 초래한다.

##### 세마포어(
dijkstra가 제안한 동기화 도구
세마포어 s: 사용 가능한 자원의 수 또는 잠김/열림 등의 상태를 나타내는 값을 저장하는 정수형 공용 변수
세마포어 s는 두 표준 단위 연산 P와 V에 의해서만 접근됨
이 세마포어를 가지고 어떻게 임계영역의 문제를 해결할까
세마포어 s는 두 표준단위 연산 P와 V에 의해서만 접근된다
P(s): 검사, 감소시키려는 시도. V(s): 증가

P(s)
```
if (s > 0) then
    s := s-1;
else
    현재의 프로세스 대기;
```
V(s)
```javascript
if (1개 이상의 프로세스가 대기중) then
    그 중 1개의 프로세스만 진행
else
    s += 1;
```

상호 배제의 구현
```
repeat
    // 세마포어 mutex의 초깃값: 1
    진입영역: P(mutex);
    임계영역
    헤제영역: V(mutex);
    잔류영역
until false;
```

node.js의 이벤트 루프중 레디큐에 프로세스들을 대기열로 표현하는 방식과 유사한 것 같다.
먼저 대기하고 있는 애를 살리는 것도 보니까 작업큐의 head 부분을 먼저 임계영역에 들여보내 주는 것으로보아
노드js는 세마포어 방식을 사용하는 것 같다. -> 협력적 멀티 태스킹이라는 주제로 운영체제 개입 없이 task가 독점적으로 운영체제를 사용하는 방식이 있다고 한다
[링크](http://playnode.io/2017/slides/nodejs-cooperative-multi-tasking.pdf)
코루틴을 사용하는 것인데 신기하네 async 와 await이 비선점적 방식이라 스레드처럼 사용할 수 있다고하네.


세마포어를 이용하면 동기화 문제 해결할 수 있다.
프로세스 A가 문장 S1을 실행한 후 프로세스 B가 문장 S2를 실행할 수 있도록 동기화(block, wakeup 프로토콜이라고 부름)
[54:37] 세마포어의 동기화 문제가 이해가 잘안됌. 

## 병행 프로세스 II
프로세스의 상호 협력이 일어나는 두가지 예시
프로세스 간의 통신

#### 병행 프로세스의 상호 협력
공통 작업을 수행하기 위해 서로 협동하는 경우
예) 생산자/소비자 문제, 판독기/기록기 문제

##### 생산자/소비자 문제
생산자가 만든 제품을 소비자가 소비한다.
여기서 제품 통신을 버퍼를 이용한다.

생산자 -> 버퍼 -> 소비자
소비자 -> 버퍼 -> 생산자

생산자는 만드는대로 버퍼에 넣어주기만 한다
소비자는 버퍼에 있는 제품을 가져오기만 하면 된다.

유한 버퍼 문제라고도 부른다.
버퍼는 일정한 크기가 정해져 있기 때문에 생산자는 버퍼에 넣는데에 한계가 있다.

생산자: 버퍼에 데이터를 채우는 프로세스
소비자: 버퍼에 있는 데이터를 읽어내는 프로세스

상호배제가 필요하다. 상호 배제를 어떻게 해결할 것인가?
생산자 입장에서 버퍼가 만약 가득 차 있다면 생산자는 대기해야 한다.
소비자 입장에서 버퍼가 비어 있다면 소비자는 대기해야 한다.
이렇게 되면 동기화 문제로 전환되게 된다.

상호 배제를 어떻게 해결할 것인가? -> 세마포어 활용:= mutex, empty, full 이용

```javascript
repeat
    nextp에 데이터 항목을 생산
    nextp를 버퍼에 넣는다.
until false;
```

```javascript
repeat
    버퍼에서 데이터 항목을 꺼내
    nextc에 넣음
    nextc를 소비
until false;
```
[10:11](코드스테이츠 때문에 제대로 못들음 다시 봐야함)
이쪽부터 세마포어를 이용해 생산자/소비자 문제를 해결하려고 했다.
Nodejs는 이 문제를 어떻게 표현하고 해결하고 있을까?

##### 판독기/기록기 문제
[17:55](판독기/기록기 문제 시작)
공유 데이터 객체 - 파일, 레코드 등
공유 데이터 객체를 읽어내는 프로세스를 판독기라고 한다.
공유 데이터 객체를 사용해 쓰는 프로세스를 기록기라고 한다.

여러개의 판독기가 동시에 공유 데이터 객체에 접근하는 것은 문제가 없다.
데이터를 쓰려고 할 때엔 상호배제가 필요하다. 읽는것은 문제 없지만 쓰는것은 문제가 있다.
우선 순위에 따른 문제의 변형
- 제1 판독기 / 기록기 문제 (판독기 우선)
기록기가 이미 공유 객체의 사용을 허가 받은 것이 아니라면 판독기는 대기하지 않음
- 제2 판독기 / 기록기 문제 (기록기 우선)

우선 순위에 따른 문제의 변형
제1 판독기 / 기록기 문제 (판독기 우선)
기록기가 이미 공유 객체의 사용을 허가 받은것이 아니라면 판독기는 대기하지 않음
기록기의 기아 상태 유발 가능성이 있음

제2 판독기/기록기 문제 (기록기 우선)
일단 기록기가 준비되었다면 기록을 가능한 한 빨리 수행할 수 있도록 한다.
판독기의 기아상태 유발 가능

##### 프로세스 통신, IPC, InterProcess Communication
프로세스들이 유기적인 데이터를 어떻게 주고받는가, 주고받는 방식에 대해서 알아보자
공유 기억장치 기법
메세지 시스템 기법
두 방법은 상호 배타적이 아님. -> 단일 운영체제 내에서 동시에 사용 가능하다
##### 공유 기억장치 기법
프로세스 간에 공유변수를 이용하여 정보를 교환
프로세스 A와 프로세스 B 간에 공유 기억장치를 두어 데이터 교환을 함.

##### 메세지 시스템 기법
메세지 교환 방식으로 정보를 교환
send/receive 연산자를 통해
소량의 데이터 교환에 유용
통신기능 제공의 책임은 운영체제에게 있다
- 직접 통신 (대칭형 / 비대칭형)
: 메세지를 전달 연산에 수신자나 송신자 이름을 명시
통신 링크는 자동으로 설정된다.
하나의 링크는 두 프로세스 사이만 연관되며 각 통신 프로세스 쌍 사이에는 정확히하나의 링크가 존재
링크는 양방향이다.
비대칭형으로 하게되면 `receive(id, message)` id 값으로 확인
대칭형으로 하게되면 `receive(q, message)` q를 명시적으로 할수잇음
- 간접 통신 (우편함): 메세지 전달 연산에 우편함 이름을 명시
Process: send(A, message) -> 우편함 <- 프로세스 Q: receive(A, message)
통신 링크는 공유 우편함이 있는 경우에만 설정된다 (gRPC)가 이런 느낌인가?
하나의 링크는 2개 이상의 프로세스들과 연관될 수 있으며, 각 통신 프로세스 쌍 사이에는 여러 링크가 존재가능
링크는 단뱡향 또는 양방향이다.
만약에 우편함이 프로세스에게 소속되어 있다면,
  프로세스 P ==: 우편함[프로세스 Q(우편함 소유)] 이라면 수신만 가능하다 Q가
  프로세스 P는 송신만 할수있음
만약에 우편함이 운영체제에게 소속되는 경우라면,
  프로세스 P == 우편함 == 프로세스 Q(우편함 생성자 -> 소유)
  수신가능               송신가능 (양방향 통신 가능)
  
##### 통신링크
프로세스들 사이에 메세지를 주고 받기 위한 연결통로
프로세스 A <-> 프로세스 B
- 논리적 구현에 대한 이슈:
    - 어떻게 링크를 설정?
    - 한 링크가 2개 이상의 프로세스와 연결 가능
    - 두 프로세스 사이에 얼마나 많은 링크가 존재하는가?
    - 링크의 용량은? 메세지의 크기는? 링크는 단방향인가? 양방향인가? -- 한번에 얼마나 많은 양의 데이터를 보낼거냐?
링크의 용량
      '0 용량' : 링크 자체에 무언가 보관할 수 있는 능력이 없음. -> P가 보낼때 Q가 받아야 가는거라서 동기화 필요
      '제한된 용량' : 중간에 버퍼 큐가 있음(크기 n) -> 자동 버퍼링 -> 큐가 가득 차면 송신자가 대기
      '무제한 용량' : 중간의 큐의 용량이 무한임 -> 자동 버퍼링 -> 송신자가 대기할 필요가 없음
      '0 용량'이 아니라면 메세지 도착 여부의 인지 방법은? -> 버퍼에 던진 데이터를 수신자가 받았늕 확인할 길이 없기 때문에
      `receive()`가 `send(P, "ack")을 호출해 메세지를 던져준다.
      그럼 P 입장에서 receive()로 "ack"을 받고 확인한다.
      -> 비동기적 통신

예외조건 처리

- 프로세스가 종료된 경우:
    송신 프로세스 Q가 종료된 경우: P를 종료, Q가 종료한 사실을 P에게 알림(별도로)
    수신 프로세스 Q가 종료된 경우: 버퍼가 없는 경우 P를 종료, Q가 종료한 사실을 P에게 알림

- 메세지를 상실한 경우
    예외조건 처리 - 메세지 상실
    프로세스 P -- 프로세스 Q
    send(P, m) -> receive(Q, m)
    운영체제가 탐지 후 메세지 재전송
    송신 프로세스가 탐지 후 메세지 전송
    운영체제가 탐지 후 송신 프로세스에게 통지
  
- 메세지가 혼합된 경우(변질된경우)
    P가 Q한테 메세지를 보낼때 잡음이 섞여서 메세지가 변질이 됬다면
    오류 탐지 후 재전송을 해주어야 함, 오류탐지는 어떻게? -> checksum()
    
