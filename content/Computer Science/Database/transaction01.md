---
title: "Database: Transaction"
date: 2021-05-12T20:28:07+09:00
draft: true
categories:
  - "Database"
tags:
  - "Transaction"
comments: true
authorbox: true
pager: true
toc: true
sidebar: "right"
widgets:
  - "search"
  - "recent"
  - "taglist"
---

#### 데이터 동시접근의 문제
동일 데이터에 다수 사용자의 접근 허용시 일관성이 훼손된다.

#### 트랜잭션의 개념
1. 데이터베이스를 조작하기 위한 하나의 논리적 단위를 이루는 일련의 연산의 집합
예) 예금 인출
   - 작업 단위: 예금 1000원 인출
   - 일련의 연산: Read(A), A = A - 1000, Write(A)
2. 데이터베이스를 사용하여 처리하는 작업을 하나의 묶음으로 인식해서 묶음 단위로 실행되도록 정의한 개념

#### 트랜잭션의 특징
1. 다수의 연산으로 구성된 트랜잭션이 사용자에게 단일 작업처럼 다뤄지도록 ACID 특징을 준수
    - 원자성(atomicity): 하나의 트랜잭션에 포함된 모든 연산은 완전히 수행되거나 전혀 수행되지 않아야 한다.
    - 일관성(consistency): 특정 트랜잭션이 수행되기 전과 후에 데이터베이스가 일관된 상태를 유지해야 한다.
    - 고립성(isolation): 특정 트랜잭션이 데이터베이스를 갱신하는 동안 다른 트랜잭션에 의해 방해받지 않아야 한다.
    - 지속성(durability): 완료된 트랜잭션의 결과는 어떠한 시스템의 장애에도 데이터베이스에 반영되어야 한다.

#### 트랜잭션의 두 연산
1. Read(X): 데이터베이스에서 데이터를 읽고 트랜잭션이 실행되는 메모리의 변수 X에 값을 저장하는 연산
2. Write(X): 트랜재션이 실행되는 메모리에 있는 변수 X의 값을 데이터베이스에 저장하는 연산
    : 트랜잭션이 확보하고 있는 메모리 공간의 변수 X의 값을 데이터베이스에 있는 X의 값에 값을 다시 써주는것
    
3. ACID 특성을 유지
```
예제
-----
READ(A)
A := A - 1000
    Write(A)
    Read(B)
B := B + 1000
    Write(B)  
```

#### 트랜잭션의 연산자
1. 트랜잭션의 연산
- Read(A): 데이터베이스에서 데이터 X를 읽고, 트랜잭션이 실행되는 메모리의 변수 X의 값을 저장하는 연산
- Write(X): 트랜잭션이 실행되는 메모리에 있는 변수 X의 값을 데이터베이스에 저장하는 연산

2. 트랜잭션 실행의 연산
- Commit: 트랜잭션 연산에 의해 갱신된 데이터 항목의 값을 데이터베이스에 반영시키고 지속성을 확보시키는 연산
- Rollback: 트랜잭션이 중단되기 이전까지 수행한 연산에 의해 갱신된 모든 데이터 항목의 값을 무효화하여 일관성을 확보하는 연산

3. 트랜잭션의 5가지 상태 변화
- 동작: 트랜잭션이 시작을 준비 또는 실행중인 상태
- 부분 커밋: 마지막 연산을 실행한 직후의 상태
   : 트랜잭션의 연산을 다 수행하고 나면 그 트랜잭션의 수행 결과가 메모리에만 남아있다.

#### 트랜잭션 동시성
1. 동시성 고려
2. 직렬 / 벙렬 스케줄

##### 동시성 고려
1. DBMS는 다수의 사용자가 데이터베이스를 공용으로 사용하기 위한 목적으로 도입
2. 트랜잭션 동시 실행의 이점
-> 트랜잭션 처리율과 자원 이용률을 향상
-> 트랜잭션의 대기 시간을 감소
3. 다중 사용자 환경에서 트랜잭션의 동시 실행으로 데이터 갱신 시, 일관성 훼손 문제가 발생
4. 동시성 제어(concurrency control)
다수의 트랜잭션이 성공적으로 동시에 실행되어도 일관성을 유지할 수 있도록 지원하는 기법
   
##### 스케쥴링
스케쥴이란 다수의 트랜잭션에 포함된 연산의 실행 순서를 명시한 것
##### 직렬 스케쥴
T과 T이 순차적으로 실행되는 스케쥴
1. 트랜잭션 간 연산 순서를 교환하여 트랜잭션을 직렬 스케쥴과 동등하게 변환이 가능한 스케쥴
2. 사용된 Read와 Write 연산 교환 시 상황에 따라 실행 결과에 일관성이 훼손되는 현상(충돌)이 발생
3. 연산 순서의 교환(단, l(i)는 T(i)의 연산)
4. 충돌 동등 => 특정 스케쥴 S에서 충돌이 일어나지 않는 연산의 순서를 바꿔 스케쥴 S로 변환이 가능한 상태
5. 충돌 직렬성 => 순서 교환이 가능한 연산을 교환하여 직렬 스케쥴의 연산과 동등하게 변환이 가능한 스케쥴

##### 병렬 스케쥴
T0과 T1의 비순차적 실행되는 스케쥴
하나의 트랜잭션이 완료되기 전에 다른 트랜재션이 실행되는 스케쥴
병렬 스케쥴의 순서로 연산을 수행할 경우 일관성의 훼손이 발생 가능

#### 트랜잭션의 회복
1. 트랜잭션의 회복의 개념
원자성을 보장하기 위해 트랜잭션 실패 시 실행된 모든 연산을 실행 이전 상태로 복원하는 기법

2. 회복 가능한 스케쥴
T(i)와 T(j)에 대해, T(i)가 기록한 데이터를 T(j)가 읽을때, T(i)의 커밋이 T(j) 보다
먼저 나타나는 스케줄

연쇄적 롤백 유발 가능성: T(7)의 롤백으로 인하여 연쇄적으로 다른 트랜잭션도 롤백되는 현상
[의미와 그림을 찾아보자]

3. 회복 불가능한 스케쥴
회복이 가능한 스케쥴로 구성되어야 일관성이 유지되는데 회복 불가능한 스케쥴이 뭔지 제대로 알아보자.
   
3. 비연쇄적 스케쥴
- 연쇄적 롤백으로 발생할 수 있는 대량의 회복 연산을 방지하기 위해 연쇄적이지 않은 스케줄로 구성된 스케줄
- T(i)가 기록한 데이터를 읽을 때 T(i)의 커밋이 T(j)의 읽기 연산보다 먼저 나타나는 스케줄

