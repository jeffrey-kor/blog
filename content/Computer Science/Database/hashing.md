---
title: "Database: Hashing"
date: 2021-05-12T19:02:33+09:00
draft: true
categories:
  - "Database"
tags:
  - "Hashing"
comments: true
authorbox: true
pager: true
toc: true
sidebar: "right"
widgets:
  - "search"
  - "recent"
  - "taglist"
---


### TL; DR
1. 해싱은 수학적 함수 개념을 사용한 데이터 관리 기법으로 버킷의 개수가 정해진 정적 해싱과 데이터베이스이 크기에 따라 버킷의 개수가 변경되는 동적 해싱으로 구분된다. <br>
2. 해시 함수는 레코드의 탐색키 값과 저장되어야 하는 버킷의 주소를 대응시키는 역할을 수행하며, 레코드가 버킷에 균등하게 배푼되는 해시 함수가 가장 이상적이다. <br>
3. 충돌 발생으로 서로 다른 탐색키가 동일한 버킷에 대응될 수 있으며 이를 동거자라고 한다. 특정 버킷에 많은 충돌이 발생하여 더 이상의 레코드나 인덱스 엔트리가 저장될 수 없을 때 이를 오버플로라 한다. <br>
4. 확장성 해싱은 데이터베이스의 크기에 따라 버킷이 확장되는 동적 해싱 기법의 일종으로 디렉토리와 버킷으로 구성되며 디렉토리의 주소와 버킷의 주소로 구성되는 모조키를 사용한다. <br>
5. 비트맵 인덱스는 다중키를 가진 질의를 보다 효율적으로 처리하기 위해 고안된 인덱스이다. 비트맵은 간단한 비트 배열로 이루어져 있다. <br>
6. 비트맵 인덱스를 사용하여 레코드를 검색 시 주어진 각각의 조건에 해당하는 비트열을 비트 AND 연산을 수행하여 최종적으로 생성되는 비트열로 조건을 만족하는 레코드의 위치를 빠르게 파악할 수 있다. <br>

## 해싱이란?
해시(hash)란 탐색키의 산술적인 연산을 통해 버킷의 주소를 계산하는 해시 함수를 사용하여 데이터 배분 및 접근하는 기법
1. hash = { 탐색키: "버킷의 주소" }
2. 버킷: 한 개 이상의 레코드를 저장할 수 있는 저장공간의 단위, 크기는 일반적으로 디스크 블록의 크기와 일치
데이터베이스에서의 해시 함수의 역할
3. 해시 파일 구조: 각각의 레코드가 디스크의 어느 버켓에 들어가야 하는지 해쉬 함수가 정함

#### 정적 해싱
1. 버킷의 개수가 고정된 해싱 기법
2. 키 값이 k(i)인 레코드 삽입 > h(Ki)를 통하여 K(i)에 대응하는 버킷 주소를 생성하고 레코드를 해당 버킷에 저장
3. 키 값이 k(i)인 레코드 검색
    - h(ki)을 통하여 버킷 주소를 생성하고 버킷에 저장된 레코드 접근
    - h(Ki)  = h(kj) = m인 경우가 발생하기 때문에 버킷 m에 저장된 모든 레코드를 탐색하여 선택하는 과정이 필요
4. 충돌과 동거자란
    충돌: 서로 다른 두 레코드가 동일한 버킷에 대응되도록 만들어진 결과가 발생했을 때 충돌이라고 한다.
    동거자: 충돌에 의해 같은 버킷 주소를 갖는 레코드

5. 오버플로우(Overflow)
    충돌과 동거자가 많아지면 당연히 오버플로우가 발생할 수 밖에 없다. 해쉬함수가 하나의 특정한 버킷에 집중되어 데이터를 저장한다면
    문제가 생길수밖에 없다. 
    1. 버킷을 하나 생성해 특정 버킷에 포인터로 참조형식으로 한다(링크드리스트처럼)
    2. 추가적인 버킷을 할당 또는 다음 버킷에 할당하여 처리
    3. 오버플로우가 발생할수록 접근 시간이 길어지고 해쉬 성능이 저하 된다.
        
6. 해시 인덱스
1. 해시 파일 구조와 동작 방식을 레코드가 아닌 인덱스 엔트리에 적용한 인덱스

7. 정적 해싱의 문제
1. 데이터베이스의 크기가 커짐에 따라 성능 감소 -> 재검색의 회수, 양도 많아지기 때문
2. 미리 큰 공간을 잡을 경우, 초기에 상당한 양의 공간을 낭비
3. 재구성 시 새롭게 서낵된 해쉬 함수를 사용하여 모든 레코드에 대하여 다시 계산하고 버킷에 할당하는 대량의 비용이 발생
4. 해쉬 구조의 크기가 동적으로 결정되는 동적 해슁 기법 제안


#### 동적 해싱
버킷의 사이즈를 버킷의 개수를 가변적으로 조절할 수 있는 해싱 기법,
데이터베이스의 크기에 따라 버킷의 크기에 비례
2. 데이터베이스의 증대 혹은 축소에 따른 인덱스의 구조를 조절하기 위해 해쉬 함수를 동적으로 변경하는 기술
3. 확장성 해싱
    1. 동적 해슁의 일종으로 디렉터리와 버킷의 2단계 구조
    2. 디렉터리는 디스크에 저장되는 버킷 주소 테이블
    3. 디렉터리 깊이를 의미하는 정수값 d를 포함하는 헤더와 데이터가 저장된 버킷에 대한 2^d개의 포인터로 구성된다.
    
확장성 해싱이란?
모조키(pseudo Key)
1. 레코드의 탐색키 값이 해쉬 함수에 의해 일정 길이의 비트 스트링으로 변환된 키
2. 모조키의 첫 d 비트를 사용하여 디렉터리에 접근
버킷 헤더(디렉터리 헤더)
1. 정수값 i(<=d) 가 저장되어 있음을 표시
2. i는 버킷에 저장되어 레코드의 모조키들이 처음부터 i 비트까지 일치함을 표시

확장성 해슁의 구조
이거 다시 공부해야함.

확장성 해슁의 분할
1. 레코드 삽입에 의해 분할된 확장성 해싱 파일
동작 구조를 이해하자
   
   
#### 비트맵 인덱스
비트맵 인덱스란, 탐색키의 중복 비율이 높은 컬럼을 대상으로 하는 질의를 효율적으로 처리하기 위해 고안된 특수한 형태의 인덱스
비트맵:
- 간단한 비트의 배열
- 릴레이션 r의 속성 A에 대한 비트맵 인덱스는 A가 가질 수 있는 값에 대해 비트맵을 구성
- 각 비트맵은 릴레이션에 있는 레코드의 수 n개 만큼 n개의 비트로 표현

비트맵 인덱스의 구성
i번째 레코드가 컬럼 A에 해당 값을 가지면 비트맵의 i번째 비트를 1로, 그렇지 않으면 0으로 설정

비트맵 인덱스의 사용
성별이 남자이고 성적이 B인 학생의 정보를 출력하고 싶을 떄,
`select * from 학생 where 성별 = "남자" AND 성적 = "B"`
2. 성별의 남자와 성적의 "B"의 비트열에 대한 비트 논리곱 연산을 수행


비트맵 인덱스의 특징
컬럼에 대한 값의 범위가 유한하고 비교적 개수가 적은 규모(컬럼)일 때 용이
적용: 직책, 학과, 혈액형 등 -> 가짓수가 많지 않지만 중복의 비율이 높은 컬럼에 대해 비트맵 인덱스의 특징이다.
종류가 많은 컬럼, 기본키 같은 것에는 사용하면 절대 안됌, 성능이 나쁨
