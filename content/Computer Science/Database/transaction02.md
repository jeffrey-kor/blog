---
title: "Transaction02"
date: 2021-05-26T14:16:01+09:00
draft: true
categories:
  - "Database"
tags:
  - "Database"
comments: true
authorbox: true
pager: true
toc: true
sidebar: "right"
widgets:
  - "search"
  - "recent"
  - "taglist"
---
`락 기반 규약` `타임스탬프 기반 규약` `교착 상태`
### 동시성 제어
- 트랜잭션 직렬화와 회복하는 스케쥴이 데이터 일관성에 영향을 미치는 여부를 판별하고 일관성이
- 유지되는 상태로 복원시키기 위해 정의된 개념 => 직렬화와 회복화가 유지되는 상태로 스케쥴을 만들어서 처리를 할 수 있어야지
  원자성과 일관성을 해치지 않는다.
- 일관성 훼손을 발생시키는 트랜잭션에 대해 동시성 제어를 통해 일관성 유지에 개입
  - 트랜잭션 간 연산의 순서를 제어
  - 어떠한 데이터 읽기, 갱신 연산에도 무결성을 유지
  - 동시에 실행되는 트랜잭션 수를 증가

#### 락 기반 규약
1. 직렬 가능성을 보장하기 위한 락(잠금)을 사용하여 데이터 항목에 연산 적용 전 트랜잭션이 락을 획득하고
연산 후 반납하도록 하는 규약

2. 락의 종류
- 공유 락(Shared lock: S): 트랜잭션 T가 LS(Q) 명령으로 데이터 항목 Q에 공유 락을 획득하면 T는 Q를 읽을 수는 있지만 쓸수는 없는 락
- 배타 락(Exclusive Lock: X): 트랜잭션 T가 LX(Q) 명령으로 데이터 항목 Q에 대한 배타 락을 획득하면, T가 Q를 읽고 쓸 수 있는 락

3. 락 양립성
1. 트랜잭션은 연산하고자 하는 데이터에 대한 락을 획득해야만 연산 진행 가능
선락 후처리
2. 락 양립성 함수
[표]
- 공유 락은 다른 공유 락과 양립 가능
- 배타 락과 다른 락과 양립 불가능
- 배타 락의 요청은 공유 락이 반납될 때까지 대기
- 락의 반납은 UN() 명령 사용
T(10)
T(11)
3. 동시 실행 스케쥴
T10이 락을 일찍 반납하여 비일관적인 상태에서 데이터 접근이 가능해져 T11이 정확하지 않은 결과값을 출력
4. 락 반납의 지연의 문제
- T(12), T(13)에 대한 부분 스케쥴
-> T12가 B에 대한 배타 락을 반환할 때까지 T13은 대기
-> T13이 A에 대한 공유 락을 반환할 때까지 T12는 대기
교착 상태(Dead Lock): 
  -> 두 트랜잭션 중 하나를 롤백
  -> 한 트랜잭션이 롤백되면 그 트랜잭션이 획득했던 모든 락은 반납

#### 2단계 락킹 규약
1. 트랜잭션은 락을 요청 반납하는 두 단계로만 구성
- 확장단계: 락을 얻을 수는 있으나 반납할 수 없는 단계
- 축소단계: 락을 반납할 수는 있지만, 새로운 락을 얻을 수 없는 단계
2. 직렬성은 보장하나 데드락은 예방 불가

#### 엄격한 락킹 규약

#### 타임스탬프 순서 규약
1. 각 트랜잭션 T(i) 실행의 순서를 판단하기 위해 타임스탬프 TS(T(i))를 부여
2. 데이터 항목에 대한 타임스탬프 할당
W-Ts(Q): Write(Q)를 성공적으로 실행한 트랜잭션 중 가장 큰 타임 스탬프
R-TS(Q): Read(Q)를 성공적으로 실행한 트랜잭션 중 가장 큰 타임 스탬프
3. 타임스탬프 할당 방법
--> 시스템 클럭 값
--> 논리적 계수기(운영체제 내부에 있음)
 [그림이 있음]
   
```javascript

```
