---
title: "Database: 인덱스의 이해"
date: 2021-05-12T16:16:38+09:00
draft: true
categories:
  - "Database"
tags:
  - "Indexing"
comments: true
authorbox: true
pager: true
toc: true
sidebar: "right"
widgets:
  - "search"
  - "recent"
  - "taglist"
---
## 인덱스란?
데이터 검색에서 발생하는 비효율적인 데이터 입출력 문제를 해결하기 위한 목적으로 시작
인덱스: DBMS에서 요청된 레코드에 빠르게 접근할 수 있도록 지원하는 데이터와 관련된 부가적인 구조
인덱싱: 인덱스를 구성하고 생성하는 작업

2. 인덱스의 탐색키를 이용하여 해당 레코드가 저장된 블럭을 디스크 저장장치 또는 메모리에서 파악하여 해당 블럭을
빠르게 적재
탐색키: 파일에서 레코드를 찾는데 사용되는 컬럼이나 컬럼의 집합을 의미한다.
   
#### 인덱스 기반의 검색 과정
데이터베이스 검색 시 기존에 저장 객체들은 상당히 무겁다. 이를 메모리 검색 효율을 위해 객체의 인덱스를 먼저
디스크에서 메모리로 모두 올리게 될 수 있고(가볍기 때문에) 메모리는 해당 객체를 인덱스를 통한 바로 접근이 가능하기 때문이다.

#### 인덱싱의 종류
순서 인덱스: 특정 값에 대해 정렬된 순서를 갖는 구조
해시 인덱스: 어떤 키 값을 어떤 버킷에 저장해야하는지 해쉬 함수를 통해 값의 균일한 분포에 기초한 구조로 해시 함수가 어떤 값이 어느 버킷에 할당되는지 결정

#### 인덱스의 평가 기준
접근 시간: 데이터를 찾는데 걸리는 시간
유지 비용: 새로운 데이터 삽입 및 기존 데이터 삭제 연산으로 인한 인덱스 구조 갱신 비용
공간 비용: 인덱스 구조에 의해 사용되는 부가적인 공간 비용

##### 순서 인덱스
1. 탐색키로 정렬된 순차 파일에 대하여 레코드에 대한 빠른 접근이 가능하도록 구성한 인덱스
>> 탐색키를 정렬하여 해당 탐색키와 탐색키에 대한 레코드와의 연계를 통하여 인덱스를 생성
예) 영문 사전, 국어 사전

종류: 밀집 인덱스, 희소 인덱스, 다단계 인덱스

순차 파일: 파일을 구조화 할 때
- 해쉬파일 구조
- 순차파일 구조
- 힙 구조
=> 레코드를 실제 디스크의 어느 레코드 부분에 적재를 해야할지 고민해야 하는 .

순차파일의 특징을 검색해볼것. 순차파일들의 마지막은 다음 순차파일의 다음 포인터를 가지고있음.

인덱스 엔트리란?

인덱스 엔트리의 구조
- 탐색키
- 포인터(블럭 ID, 오프셋)

#### 밀집 인덱스
1. 모든 레코드에 대해 탐색키 | 포인터 쌍을 유지
예) 
   
#### 희소 인덱스
1. 인덱스의 엔트리가 일부의 탐색키 값만을 유지
듬성듬성 탐색키를 만들어 참조하고 있는 상황
COM31을 찾고 싶으면 COM11을 찾고 거기서부터 찾는 것
단점: 모든 엔트리에 인덱스 엔트리가 만들어져 있는게 아니기 때문에 찾고 검색을 다시한번 해야함
어떨때 쓸까?

#### 다단계 인덱스
1. 4KB 크기의 한 블럭에 100개의 엔트리가 삽입될 때, 100,000,000개의 레코드에 대한 순서 인덱스
> 1,000,000개의 블럭 = 4GB의 공간 필요
2. 인덱스 크기에 따른 검색 성능
인덱스 크기 < 메모리 크기
   - 디스크 I/O이 줄어 탐색 시간이 축소
인덱스 크기 > 메모리 크기
   - 저장된 블럭을 여러번 나누어 읽어야 하기 때문에 디스크 I/O 비용이 증가하여 탐색 시간이 증가
=> 다단계 인덱스 구성

1. 내부 인덱스와 외부 인덱스로 구성
=> 외부 인덱스를 내부 인덱스보다 희소한 인덱스로 구성하여 엔트리의 포인터가 내부 인덱스 블럭을 지칭
=> 포인터가 가리키는 블럭을 스캔하여 원하는 레코드보다 작거나 같은 탐색키 값 중에 가장 큰 값을 가지는 레코드를 탐색
2. 내부 인덱스는 1,000,000개의 블럭을 갖는 반면 외부 인덱스는 100개의 블럭만 사용하여 작은 크기의 외부 인덱스로 메모리에 적재 가능

#### B+ 트리 인덱스
[4, 1, 8, 6, 3, 14, 13, 7, 10] 7을 어떻게 찾을 수 있을까?
데이터가 1억개라면 5천만개를 뒤집어야함 -> 비효율
그럼 어떻게?
1. 정렬해놓고, 중간 먼저 찾아보고 7이면 리턴
2. 중간보다 작으면 왼쪽, 크면 오른쪽
-> 이진탐색을 구조적으로 할 수 있게 해놓은 자료구조가 이진 탐색 트리

루트 노드
중간 노드
단말 노드

: 루트 노드로부터 모든 단말 노드에 이르는 경로의 길이가 같은 높이 균형 트리
- 순서 인덱스는 파일이 커질 수록 데이터 탐색에 있어서 접근 비용이 커지는 문제점을 해결하기 위해 제안
- 상용 DBMS에서도 널리 사용되는 대표적인 순서 인덱스
- B+ 트리의 노드 구조
  [P1, K1, P2 ... P(n-1), K(n-1), P(n)] fanout이 몇개야 < 찾아볼거, 어떤 노드의 하위 노드가 몇개야
- B+ 트리의 구성 요소
    - 인덱스 세트: 루트 노드와 중간 노드로 구성
        - 단말 노드에 있는 탐색키 값을 신속하게 찾아갈 수 있도록 경로를 제공하는 목적으로 사용
    - 순차 세트: 단말 노드로 구성
        - 모든 노드가 순차적으로 서로 연결 (형제 노드가 누구있느냐를 가리키고 있는 포인터가 있기 때문)
        - 단말 노드는 적어도 (n-1)/2개의 탐색키를 포함
        - 탐색키에 대한 실제 레코드를 지칭하는 포인터를 제공
        - 단말 노드의 구성
        - 단말노드만이 실제 레코드를 가리키고 있는 포인터를 가지고 있다는 걸 유념하자

B+ 트리 상에서의 삽입, 삭제
1. 레코드 삽입, 삭제 시 B+ 트리 수정
    - 레코드 삽입: 노드에서 유지해야 할 탐색키와 포인터 수 증가로 인해 노드를 분할해야 하는 경우가 발생
    - 레코드 삭제: 노드에서 유지해야 할 탐색키 값과 포인터 수 감소로 형제 노드와 키를 재 분배 또는 병합해야 하는 경우가 발생
    - 높이 균형 유지: 노드가 분할되거나 병합되면서 높이의 균형이 맞지 않으면 전체 트리를 재 구조화 해야하므로 이런 단점이 있다.

1. 삽입: 검색과 같은 방법을 사용하여 삽입되는 레코드의 탐색키 값이 속할 단말 노드를 탐색
    - 해당 단말 노드에 <탐색키, 포인터> 쌍을 삽입
    - 삽입 시 탐색키가 순서를 유지
2. 삭제: 삭제될 레코드의 탐색키를 통해 삭제될 탐색키와 포인터를 포함한 단말 노드를 탐색
    - 같은 탐색키 값을 가지는 다중 엔트리가 존재할 경우 삭제될 레코드를 가리키는 엔트리를 찾을 때까지 탐색 후 단말 노드에서 제거
    - 단말 노드에서 제거된 엔트리의 오른쪽에 있는 엔트리들은 빈 공간이 없도록 왼쪽으로 이동

삽입은 분할, 삭제는 병합이라는 추가적인 연산이 필요할 수 있다.
=> 삽입 대상 노드에 추가적으로 저장할 공간이 부족하게 되면 노드를 분할해서 저장해야한다.
=> 부모 노드의 값도 조정해야함. 포인터로 가리켜야 하므로, 
B+ tree visualization
